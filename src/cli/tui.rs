//AUTOGENERATED -> Please be careful with this or else this will fu*k your brain

use ratatui::{
    backend::CrosstermBackend,
    Terminal,
    widgets::{Block, Borders, Paragraph},
    layout::{Layout, Constraint, Direction},
    style::{Color, Modifier, Style},
    text::{Line, Span},
};
use crossterm::{
    terminal::{enable_raw_mode, disable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},
    execute,
    event::{self, Event, KeyEvent, KeyCode},
};
use std::io::{stdout, Result};
use std::collections::HashSet;

use crate::models::graph::Graph;

pub struct TreeNode {
    pub id: String,
    pub title: String,
    pub content: String,
    pub tags: Vec<String>,
    pub depth: usize,
    pub is_expanded: bool,
}

pub struct TreeState {
    pub nodes: Vec<TreeNode>,
    pub selected_idx: usize,
    pub expanded_nodes: HashSet<String>,
}

impl TreeState {
    pub fn from_graph(graph: &Graph) -> Self {
        let mut nodes = Vec::new();
        let mut expanded_nodes = HashSet::new();

        // Find root nodes (nodes with no incoming edges)
        let all_node_ids: HashSet<String> = graph.nodes.keys().cloned().collect();
        let has_incoming: HashSet<String> = graph
            .edges
            .iter()
            .map(|e| e.to.clone())
            .collect();

        let root_ids: Vec<String> = all_node_ids
            .iter()
            .filter(|id| !has_incoming.contains(*id))
            .cloned()
            .collect();

        // If no roots found, use all nodes
        let start_ids = if root_ids.is_empty() {
            all_node_ids.iter().take(5).cloned().collect()
        } else {
            root_ids
        };

        // Build tree recursively
        for id in start_ids {
            TreeState::add_node_recursive(graph, &id, 0, &mut nodes, &mut expanded_nodes);
        }

        Self {
            nodes,
            selected_idx: 0,
            expanded_nodes,
        }
    }

    fn add_node_recursive(
        graph: &Graph,
        node_id: &str,
        depth: usize,
        nodes: &mut Vec<TreeNode>,
        expanded: &mut HashSet<String>,
    ) {
        if let Some(node) = graph.get_node(node_id) {
            nodes.push(TreeNode {
                id: node.id.clone(),
                title: node.title.clone(),
                content: node.content.clone(),
                tags: node.tags.clone(),
                depth,
                is_expanded: depth == 0, // Expand root nodes by default
            });

            if depth == 0 {
                expanded.insert(node_id.to_string());
            }

            // Get child nodes
            let children: Vec<String> = graph
                .edges
                .iter()
                .filter(|e| e.from == node_id)
                .map(|e| e.to.clone())
                .collect();

            for child_id in children {
                if depth < 3 {
                    // Limit depth to prevent explosion
                    TreeState::add_node_recursive(graph, &child_id, depth + 1, nodes, expanded);
                }
            }
        }
    }

    pub fn toggle_expanded(&mut self) {
        if self.selected_idx < self.nodes.len() {
            let node_id = self.nodes[self.selected_idx].id.clone();
            if self.expanded_nodes.contains(&node_id) {
                self.expanded_nodes.remove(&node_id);
            } else {
                self.expanded_nodes.insert(node_id);
            }
        }
    }

    pub fn move_up(&mut self) {
        if self.selected_idx > 0 {
            self.selected_idx -= 1;
        }
    }

    pub fn move_down(&mut self) {
        if self.selected_idx < self.nodes.len().saturating_sub(1) {
            self.selected_idx += 1;
        }
    }

    pub fn get_visible_nodes(&self) -> Vec<&TreeNode> {
        let mut visible = Vec::new();
        let mut skip_depth = None;

        for node in &self.nodes {
            // Skip nodes that are children of collapsed parents
            if let Some(skip) = skip_depth {
                if node.depth > skip {
                    continue;
                } else {
                    skip_depth = None;
                }
            }

            visible.push(node);

            // Mark this node's children to be skipped if it's collapsed
            if !self.expanded_nodes.contains(&node.id) && !node.id.is_empty() {
                skip_depth = Some(node.depth);
            }
        }

        visible
    }
}

pub fn launch_tui(graph: &Graph) -> Result<()> {
    enable_raw_mode()?;
    let mut stdout = stdout();
    execute!(stdout, EnterAlternateScreen)?;

    let backend = CrosstermBackend::new(stdout);
    let mut terminal = Terminal::new(backend)?;

    let mut tree_state = TreeState::from_graph(graph);

    loop {
        terminal.draw(|frame| {
            draw_ui(frame, &tree_state);
        })?;

        if event::poll(std::time::Duration::from_millis(200))? {
            if let Event::Key(KeyEvent { code, .. }) = event::read()? {
                match code {
                    KeyCode::Char('q') | KeyCode::Esc => break,
                    KeyCode::Down | KeyCode::Char('j') => tree_state.move_down(),
                    KeyCode::Up | KeyCode::Char('k') => tree_state.move_up(),
                    KeyCode::Enter | KeyCode::Char('l') => tree_state.toggle_expanded(),
                    KeyCode::Right => tree_state.toggle_expanded(),
                    KeyCode::Left => {
                        if tree_state.selected_idx < tree_state.nodes.len() {
                            let node_id = tree_state.nodes[tree_state.selected_idx].id.clone();
                            tree_state.expanded_nodes.remove(&node_id);
                        }
                    }
                    _ => {}
                }
            }
        }
    }

    disable_raw_mode()?;
    execute!(terminal.backend_mut(), LeaveAlternateScreen)?;
    Ok(())
}

fn draw_ui(frame: &mut ratatui::Frame, tree_state: &TreeState) {
    let size = frame.size();

    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints([
            Constraint::Length(3),
            Constraint::Min(10),
            Constraint::Length(3),
        ])
        .split(size);

    // Header
    let header = Paragraph::new(vec![Line::from(vec![
        Span::styled("üìå ", Style::default().fg(Color::Cyan)),
        Span::styled("Knowledge Graph Mind Map", Style::default().fg(Color::Cyan).add_modifier(Modifier::BOLD)),
    ])])
    .block(Block::default().borders(Borders::BOTTOM).border_style(Style::default().fg(Color::DarkGray)));
    frame.render_widget(header, chunks[0]);

    // Tree View
    let visible_nodes = tree_state.get_visible_nodes();
    let mut tree_lines = Vec::new();

    for (idx, node) in visible_nodes.iter().enumerate() {
        let is_selected = idx == tree_state.selected_idx;
        let node_id = &node.id;
        
        // Calculate indentation
        let indent = "  ".repeat(node.depth);
        
        // Determine expansion symbol
        let expand_symbol = if tree_state.expanded_nodes.contains(node_id) {
            "‚ñº"
        } else {
            "‚ñ∂"
        };

        // Build the line
        let line_content = format!(
            "{}{} {}",
            indent,
            expand_symbol,
            node.title
        );

        let style = if is_selected {
            Style::default()
                .fg(Color::Black)
                .bg(Color::Cyan)
                .add_modifier(Modifier::BOLD)
        } else if node.depth == 0 {
            Style::default().fg(Color::Yellow).add_modifier(Modifier::BOLD)
        } else if node.depth == 1 {
            Style::default().fg(Color::Green)
        } else {
            Style::default().fg(Color::White)
        };

        let line = Line::from(vec![Span::styled(line_content, style)]);
        tree_lines.push(line);
    }

    let tree_widget = Paragraph::new(tree_lines)
        .block(
            Block::default()
                .title(" Tree View (‚Üë/‚Üì Navigate, Enter/‚Üí Expand, ‚Üê Collapse, q Quit) ")
                .borders(Borders::ALL)
                .border_style(Style::default().fg(Color::DarkGray)),
        )
        .style(Style::default().fg(Color::White));

    frame.render_widget(tree_widget, chunks[1]);

    // Node Details
    if let Some(selected_node) = visible_nodes.get(tree_state.selected_idx) {
        let details = format!(
            "ID: {}  |  Tags: {}",
            selected_node.id,
            if selected_node.tags.is_empty() {
                "None".to_string()
            } else {
                selected_node.tags.join(", ")
            }
        );

        let footer = Paragraph::new(vec![
            Line::from(vec![Span::styled(
                &selected_node.title,
                Style::default().fg(Color::Cyan).add_modifier(Modifier::BOLD),
            )]),
            Line::from(vec![Span::raw(&selected_node.content)]),
            Line::from(vec![Span::styled(details, Style::default().fg(Color::DarkGray))]),
        ])
        .block(Block::default().borders(Borders::TOP).border_style(Style::default().fg(Color::DarkGray)));

        frame.render_widget(footer, chunks[2]);
    }
}
